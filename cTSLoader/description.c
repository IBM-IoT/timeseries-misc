/* Auto generated from TSLoader.txt */
printf ("  \n");
printf ("DESCRIPTION\n");
printf ("  The TSLoader client programs facilitate fast insertion of TimeSeries data.\n");
printf ("\n");
printf ("  TSL_Init is used to initialise the internal TimeSeries loader structures\n");
printf ("  in the Informix server. It requires a database name, the table name and\n");
printf ("  the TimeSeries column name. It executes the SQL function TSL_Init(). This\n");
printf ("  must be called before any loading takes place. It is recommended that the\n");
printf ("  TimeSeries base table is seeded first with data before running TSL_Init.\n");
printf ("  It must have been run before attempting to use TSL_Load. \n");
printf ("\n");
printf ("  TSL_Load is the data loader client. It also requires the database, table\n");
printf ("  and column name. It expects data in the standard '|' delimited format for\n");
printf ("  unloaded data. The field ordering must be:\n");
printf ("\n");
printf ("    primarykey|timestamp|field1|field2|field3|...\n");
printf ("\n");
printf ("  If it is a composite primary key then each part of the key must be '|'\n");
printf ("  delimited. The complete requirements for the input data format is specified\n");
printf ("  in the TimeSeries manual.\n");
printf ("\n");
printf ("  The TSL_Load program reads the input stream and creates\n");
printf ("  buffers of lines suitable for using with the SQL function TSL_Put().\n");
printf ("  After one or more buffers have been sent to the server they are\n");
printf ("  usually flushed to disk using the SQL function TSL_Commit(). See the\n");
printf ("  TRANSACTIONS section for more information.\n");
printf ("\n");
printf ("  The TSL_Shutdown program is used to free up the server resources. After\n");
printf ("  running this program it will be necessary to re-run TSL_Init.\n");
printf ("\n");
printf ("  The three programs are actually a single executable, just linked to a\n");
printf ("  different name.\n");
printf ("\n");
printf ("OPTIONS\n");
printf ("  --usage                Print a list of available options.\n");
printf ("  --man                  Print this man page.\n");
printf ("  --version              Print some version information.\n");
printf ("  --verbose              Print more informative messages.\n");
printf ("  --database dbname      Database to connect to. Can be in dbname@server format.\n");
printf ("  --table tabname        TimeSeries base table.\n");
printf ("  --user username        Connect as this user name.\n");
printf ("  --password passwd      Connect with this password.\n");
printf ("  --column ts_column     Column in table defined as type TimeSeries.\n");
printf ("  --logfile file         This is for the server to log messages to. A full\n");
printf ("  	    		 path name is required\n");
printf ("  --datetime dt_format   This is the format of the time stamp field in the\n");
printf ("                         data it follows the same convention as the Informix\n");
printf ("			 DBFORMAT environment variable. The default\n");
printf ("			 is '%%Y-%%m-%%d %%H:%%M:%%S'.\n");
printf ("  --input { file | '-' }  The input data can be in a file or read from\n");
printf ("                         standard input.\n");
printf ("  --input-dir dirname    The input data is picked up from a directory structure\n");
printf ("                         with this as the root.\n");
printf ("  --readers              Number of directory reader threads.\n");
printf ("  --one-shot             Normally the input directory is continually scanned\n");
printf ("  			 for input files. With this option the loader will\n");
printf ("			 terminate when no more files are available.\n");
printf ("  --tx-size nrows        The commit interval can be set based on the number of\n");
printf ("                         incoming rows. The default is 10000.\n");
printf ("  --status nseconds      The current loading progress is printed every few\n");
printf ("                         seconds. \n");
printf ("  --tsl-rejects file     This file name is passed to the server for\n");
printf ("                         internally rejected rows to be sent to.\n");
printf ("  --put-count nbuffers   The number of TSL_Put() calls made before the data\n");
printf ("                         gets flushed to disk. The default is 1. Caution should\n");
printf ("			 be exercised when increasing this value as it could\n");
printf ("			 cause excesive memory usage in the server and increase\n");
printf ("			 the posibility of generating a long transaction. It is\n");
printf ("			 also counter productive to have a lot of data to flush\n");
printf ("			 in one go as it ties up the server and prevents other\n");
printf ("			 processing.\n");
printf ("  --put-buffer bufsize   The size of the buffer used by TSL_Put(). The maximum\n");
printf ("  	       		 size is that of an LVARCHAR.\n");
printf ("  --putbuf-dir dirname   Use TSL_Put (<handle>, 'FILE:/...') and use a file to\n");
printf ("  	       		 store the data instead of sending a buffer over SQLI.\n");
printf ("  --lock-containers      There is some optimisation in the server to reduce the\n");
printf ("  			 calls to the internal lock manager when the whole\n");
printf ("			 container is locked. However it has implication for\n");
printf ("			 the way transactions work, see the TRANSACTIONS section\n");
printf ("			 for more details.\n");
printf ("  --no-info              Don't use the TSL_FlushInfo() SQL function to gather\n");
printf ("  			 statistics from the flush to disk call. It saves a\n");
printf ("			 small amount of network traffic.\n");
printf ("  --rejects file         This file is used to log the incoming lines of data\n");
printf ("  	    		 that are rejected by the client loader.\n");
printf ("  --threads N            Specify the number of threads to use for loading. See\n");
printf ("  	    		 the section on PERFORMANCE for more details.\n");
printf ("  --flush-flag N         Use this flag as the basis for the flag used when data\n");
printf ("  	       		 is flushed. This can be used to control the way\n");
printf ("			 duplicate data is handled. The default is 5.\n");
printf ("  --flush-interval N     If the input data stream goes idle or there are no\n");
printf ("                         files to process then data may be sitting in put\n");
printf ("			 buffers. Check every N seconds for this and do a\n");
printf ("			 forced flush of the data so it is sent to disk.\n");
printf ("  --reduced-log          Incorporate the reduced logging flag (256) when\n");
printf ("  			 the data is flushed.\n");
printf ("  --to-utc column_number  TimeSeries stores time stamps either in UTC or in\n");
printf ("  	   		 localtime but has no provision for daylight savings.\n");
printf ("			 Use this flag in order to convert from localtime\n");
printf ("			 with daylight savings to UTC. It is important that\n");
printf ("			 the time stamps for the period of the daylight\n");
printf ("			 change over are in time stamp order.\n");
printf ("  --pass-through { 0 | 1 | 2 }  For testing purposes it is possible to run the loader\n");
printf ("			 in pre-processing mode without sending the data to the\n");
printf ("			 server.\n");
printf ("			 0  Read data and process it. Database calls are NOPs.\n");
printf ("			 1  Data is pre-processed and sent to stdout.\n");
printf ("			 2  Data is pre-processed and sent to stderr.\n");
printf ("  --fix-non-ascii        If there are any control charcters in the input they\n");
printf ("  			 are transformed into '?' to make them acceptable for\n");
printf ("			 insertion into the database. Otherwise the input row\n");
printf ("			 will be rejected. Rejected rows will be recorded in\n");
printf ("			 the client rejects file (--rejects) if specified. \n");
printf ("  --skip-repeat-columns [ ncols ]  Turn on the feature that replaces repeating\n");
printf ("  			 values with NULL to reduce the storage requirements.\n");
printf ("			 Optionally specify the number of leading fields in the\n");
printf ("			 data that should be preserved.\n");
printf ("  --repeat-marker N      When using repeat replacement, how often a full row,\n");
printf ("  		  	 without NULLs, is written. Default 100.\n");
printf ("  --remove-allnulls      For very aggresive space saving it is possible to\n");
printf ("  			 entirely remove redundant data when all the values\n");
printf ("			 in the element are NULL. This is only suitable for\n");
printf ("			 irregular TimeSeries data.\n");
printf ("TRANSACTIONS\n");
printf ("  The default mode when running TSL_Load is to use the TSL_Commit() SQL function\n");
printf ("  to flush the data to disk. The transaction size can be controlled by using\n");
printf ("  the --tx-size option. Be careful when increasing the size of this parameter,\n");
printf ("  the larger the value the more likelyhood of hitting a long transaction. It\n");
printf ("  also will have an adverse effect on memory usage if the --reduced-log option\n");
printf ("  is used as well.\n");
printf ("\n");
printf ("  If the --lock-containers option is used then it is not possible to use\n");
printf ("  TSL_Commit() because the commit of the first internal transaction will\n");
printf ("  release the lock. WHen this option is used the TSL_FlushAll() function\n");
printf ("  is used within a single transaction. This makes the transaction size\n");
printf ("  dependent on the size of the put buffer and number of buffers sent before\n");
printf ("  the flush. Similar care shold be taken here not to make the transaction too\n");
printf ("  large.\n");
printf ("\n");
printf ("  It is suggested that the maximum transaction size should be less than 100,000\n");
printf ("  rows and that no more than 25 puts are performed before a flush.\n");
printf ("  \n");
printf ("PERFORMANCE\n");
printf ("  The main goal of the TSLoader client is to get the best insert performance \n");
printf ("  for TimeSeries data by using the TSL API built into the server. AS well as\n");
printf ("  using this efficient API it also has some optimisations available that\n");
printf ("  will further boost performance.\n");
printf ("\n");
printf ("Multithreading  The number of threads used to insert data can be configured\n");
printf ("  to make the best use of the hardware available, although this will be\n");
printf ("  dependent on the way the TimeSeries data has been physically laid out.\n");
printf ("\n");
printf ("  To reduce the possibility of contention among threads, each loader\n");
printf ("  thread is dedicated to a set of containers. This ensures that no loader\n");
printf ("  thread will work on the same container as any other. To do this, TSL_Load\n");
printf ("  must read in the TimeSeries base table on start up to establish a mapping of\n");
printf ("  primary key to container name. This mapping is fixed for the time that the\n");
printf ("  loader is running. This means that any new TimeSeries inserted after the\n");
printf ("  loader has started will not be in the map and incoming data for that\n");
printf ("  TimeSeries will be discarded.\n");
printf ("\n");
printf ("  In order for this to be advantageous it is necessary to spread the\n");
printf ("  TimeSeries data evenly, among multiple containers. Once this is done the\n");
printf ("  optimum number of threads wil be based on the number of available CPUs.\n");
printf ("\n");
printf ("  When using the --input-dir option it is possible to specify the number\n");
printf ("  of threads that will be processing the files with the --readers option.\n");
printf ("\n");
printf ("  In cluster and multi-server modes the number of threads for each node is\n");
printf ("  derived from the number of CPUs on the node. If --threads is specified in\n");
printf ("  this context it will override this on a per-node basis.\n");
printf ("\n");
printf ("Batch Processing  The most efficient method for inserting TimeSeries data is using batches\n");
printf ("  of data that is sorted by primary key and then time stamp. This greatly\n");
printf ("  reduces the internal overhead generated when different TimeSeries have to\n");
printf ("  be opened and closed for only a single insert candidate.\n");
printf ("\n");
printf ("  In batch mode\n");
printf ("  it is also useful to consider the reduced logging flag where multiple\n");
printf ("  elements for the same page will almost halve the number of loggical log\n");
printf ("  records required.\n");
printf ("\n");
printf ("Storage Optimisation  NULL values in TimeSeries fields take up no space so it can be a useful\n");
printf ("  storage optimisation to turn default, or often repeated, values into NULLs.\n");
printf ("  This can be accomplished in the loader using the --skip-repeat-columns\n");
printf ("  option.\n");
printf ("\n");
printf ("  With this option turned on, any time a value is repeated for\n");
printf ("  a TimeSeries it will be replaced with a NULL to save space. So this\n");
printf ("  sequence of rows\n");
printf ("  \n");
printf ("    key1|2015-02-12 17:22:00|1|2|3|A|\n");
printf ("    key1|2015-02-12 17:23:00|2|2|3|B|\n");
printf ("    key1|2015-02-12 17:24:00|2|2|3||\n");
printf ("    key1|2015-02-12 17:25:00|3|2|4|C|\n");
printf ("\n");
printf ("  Will be sent to the server as:\n");
printf ("  \n");
printf ("    key1|2015-02-12 17:22:00|1|2|3|A|\n");
printf ("    key1|2015-02-12 17:23:00|2|||B|\n");
printf ("    key1|2015-02-12 17:24:00|||||\n");
printf ("    key1|2015-02-12 17:25:00|3||4|C|\n");
printf ("\n");
printf ("  The NULLs in the transformed data will take up no space on disk. This can be\n");
printf ("  a significant saving if there is a lot of repeated data. There are however\n");
printf ("  some limitations with this approach.\n");
printf ("\n");
printf ("  o  When querying the data it is necessary to replace the NULLs with the\n");
printf ("  correct value. This will need to be done manually in the query client or\n");
printf ("  in the server by using the ProjectedClip() function with the column(nn)\n");
printf ("  specifier to look back though the data set for the last non-NULL value.\n");
printf ("  Because of the possible processing overhead when going back a long way, a\n");
printf ("  marker row with all the correct values is inserted at an interval\n");
printf ("  determined by the --repeat-marker option.\n");
printf ("\n");
printf ("  o  It is important to ensure that data is always recieved in time stamp order.\n");
printf ("  Any out of order data will get a NULL replacement based on the preceeding\n");
printf ("  input row; which may not be appropriate.\n");
printf ("\n");
printf ("  o  There is no provision for handling a true NULL within the input data.\n");
printf ("  It will be subject to repeat replacement when queried.\n");
printf ("\n");
printf ("  It may not be appropriate to apply the repeat replacement scheme to all\n");
printf ("  fields in the data. In this case the first N fields can be protected by\n");
printf ("  specifying N to the --skip-repeat-columns option. For example with N=2\n");
printf ("  the above example data would look like this.\n");
printf ("\n");
printf ("    key1|2015-02-12 17:22:00|1|2|3|A|\n");
printf ("    key1|2015-02-12 17:23:00|2|2|3|B|\n");
printf ("    key1|2015-02-12 17:24:00|2|2|||\n");
printf ("    key1|2015-02-12 17:25:00|3|2|4|C|\n");
printf ("  \n");
printf ("  For more aggresive optimisation it is possible to discard rows where NULL\n");
printf ("  replacement would generate a row with all values being NULL. This can be\n");
printf ("  turned on with the --remove-allnulls option. It will work in conjunction\n");
printf ("  with the skipping of initial fields where equality of value to the previous\n");
printf ("  row is used rather than the value being NULL. It is an option best suited\n");
printf ("  to irregular data where values are propogated forwards by default.\n");
printf ("\n");
printf ("Data Directory  When using the --input-dir option there must be the following\n");
printf ("  sub-directories available: Input, Process, Complete. A file ending\n");
printf ("  in .tsl placed in the Input sub-directory will be processed by the loader.\n");
printf ("  While being processed it is moved to the Process sub-directory and then\n");
printf ("  moved to the Complete directory when processing is finished. If the load\n");
printf ("  is interrupted the part processed files remain in the Process directory.\n");
printf ("\n");
printf ("EXAMPLES\n");
printf ("  TSL_Init --database stores_demo --table ts_data --column raw_reads --datetime '%%Y-%%m-%%d %%H:%%M:%%S.%%F3' --logfile ${PWD}/loader.log\n");
printf ("\n");
printf ("  This initialises the server for fast loading of TimeSeries data. The input\n");
printf ("  time stamp is of type DATETIME YEAR TO FRACTION(3) and the log for server\n");
printf ("  messages is specified.\n");
printf ("  \n");
printf ("  cat input.unl | TSL_Load --database stores_demo --table ts_data --column raw_reads --input - --status 10 --put-count 5 --rejects ${PWD}/bad_input.log --tsl-rejects ${PWD}/reject.log --threads 4\n");
printf ("\n");
printf ("  Here, the loader reads from stdin, prints a status message (elememt count\n");
printf ("  and rate) every 10 seconds. After every 5 calls to TSL_Put() a flush is\n");
printf ("  performed. Any input lines with bad data is logged by the client to\n");
printf ("  the bad_input.log file, any rows rejected by the server are logged in\n");
printf ("  the reject.log file. Four loader threads will be used to insert the data.\n");
printf ("  \n");
printf ("  TSL_Shutdown --database stores_demo --table ts_data --column raw_reads\n");
printf ("\n");
printf ("  The fast loader API in the server is shutdown.\n");
printf ("\n");
printf ("ENVIRONMENT\n");
printf ("  The standard Informix environment variables for making a database\n");
printf ("  connection need to be set. INFORMIXDIR, INFORMIXSQLHOSTS, INFORMIXSERVER\n");
printf ("  and also LD_LIBRARY_PATH needs to include the client library directories.\n");
printf ("\n");
printf ("  If FET_BUF_SIZE is not in the environment then it is set to twice the\n");
printf ("  size of the put buffer.\n");
printf ("  \n");
printf ("TO DO\n");
printf ("  Monitor incoming time stamps when removing repeating fields and produce\n");
printf ("  a warning for any out of order data that will invalidate the NULL\n");
printf ("  replacement strategy.\n");
printf ("\n");
printf ("  Specify a column list for the fields that are subject to NULL replacement.\n");
printf ("\n");
printf ("  Enable multi-node inserts to a clustered GRID.\n");
printf ("\n");
printf ("  Fix the use of --threads to be more consistent.\n");
printf ("\n");
printf ("  The mapping of containers to loader threads should take account of\n");
printf ("  the physical dbspace to reduce contention.\n");
printf ("\n");
printf ("SEE ALSO\n");
printf ("  The Informix TimeSeries manual and the Informix Performance\n");
printf ("  Tuning Guide.\n");
printf ("  \n");
printf ("BUGS\n");
printf ("  Probably more than you can imagine.\n");
printf ("\n");
printf ("AUTHOR\n");
printf ("  Cosmo@uk.ibm.com\n");
printf ("\n");
